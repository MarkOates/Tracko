properties:


  - name: pieces
    type: std::vector<std::vector<Tracko::Piece>>
    init_with: '{}'
    getter: true
    getter_ref: true
    setter: true

  - name: swap_piece
    type: Tracko::Piece
    init_with: '{}'
    getter: false
    setter: true

  - name: num_rows
    type: int
    init_with: 0
    getter: true
    setter: false

  - name: num_columns
    type: int
    init_with: 0
    getter: true
    setter: false

  - name: cursor_x
    type: int
    init_with: 0
    getter: true
    setter: false

  - name: cursor_y
    type: int
    init_with: 0
    getter: true
    setter: false


methods:


  - name: move_cursor_up
    body: |
      cursor_y -= 1;
      if (cursor_y < 0) cursor_y = 0;
      return;


  - name: move_cursor_down
    body: |
      cursor_y += 1;
      if (cursor_y >= num_rows) cursor_y = (num_rows - 1);
      return;


  - name: move_cursor_left
    body: |
      cursor_x -= 1;
      if (cursor_x < 0) cursor_x = 0;
      return;


  - name: move_cursor_right
    body: |
      cursor_x += 1;
      if (cursor_x >= num_columns) cursor_x = (num_columns - 1);
      return;


  - name: swap
    guards: [ can_swap() ]
    body: |
      // TODO: Test this
      Tracko::Piece *piece_at_cursor = get_piece_at_cursor();
      Tracko::Piece intermediate_piece = *piece_at_cursor;
      *piece_at_cursor = swap_piece;
      swap_piece = intermediate_piece;
      return;


  - name: can_swap
    type: bool
    body: |
      if (!cursor_is_in_valid_position()) return false;
      Tracko::Piece *piece_at_cursor = get_piece_at_cursor();
      return piece_at_cursor->infer_can_swap();


  - name: calculate_adjacency
    type: std::pair<bool, std::pair<int, int>>
    parameters:
      - name: x1
        type: int
        default_argument: 0
      - name: y1
        type: int
        default_argument: 0
      - name: x2
        type: int
        default_argument: 0
      - name: y2
        type: int
        default_argument: 0
    body: |
      std::pair<int, int> difference = { x1 - x2, y1 - y2 };
      std::set<std::pair<int, int>> valid_adjacent_numbers = {
         { -1, 0 },
         { 0, -1 },
         { 1, 0 },
         { 0, 1 },
      };
      if (valid_adjacent_numbers.find(difference) == valid_adjacent_numbers.end()) return { false, difference };
      return { true, difference };
    body_dependency_symbols:
      - std::set


  - name: have_connecting_edges
    type: bool
    parameters:
      - name: x1
        type: int
        default_argument: 0
      - name: y1
        type: int
        default_argument: 0
      - name: x2
        type: int
        default_argument: 0
      - name: y2
        type: int
        default_argument: 0
    body: |
      // Coordinates are on the board
      if (!is_valid_tile_coordinate(x1, y1)) return false;
      if (!is_valid_tile_coordinate(x2, y2)) return false;

      // Check if pieces are adjacent
      bool are_adjacent = false;
      std::pair<int, int> adjacency = { 0, 0 };
      std::tie(are_adjacent, adjacency) = calculate_adjacency(x1, y1, x2, y2);
      if (!are_adjacent) return false;

      // Pieces are in a connectable state
      Tracko::Piece* piece_a = get_piece(x1, y1);
      Tracko::Piece* piece_b = get_piece(x2, x2);

      std::pair<Tracko::Piece::ConnectingPosition, Tracko::Piece::ConnectingPosition> piece_a_connections =
         Tracko::Piece::get_connecting_positions(piece_a->get_tile_type());
      std::pair<Tracko::Piece::ConnectingPosition, Tracko::Piece::ConnectingPosition> piece_b_connections =
         Tracko::Piece::get_connecting_positions(piece_b->get_tile_type());

      // Get the connecting edges

      // HERE
      // TODO: This method, need to take into account if:
      // 1) piece is in a connectable state
      // 2) piece has the matching connection
      // 3) source's connection does not match to edge of map
      // 4) other stuff
      //CONNECTING_POSITION_LEFT
      //CONNECTING_POSITION_TOP
      //CONNECTING_POSITION_RIGHT
      //CONNECTING_POSITION_BOTTOM
      //throw std::runtime_error("Tracko::Board HERE");
      return true;


  - name: cursor_is_in_valid_position
    type: bool
    body: |
      if (cursor_x < 0) return false;
      if (cursor_y < 0) return false;
      if (cursor_x >= num_columns) return false;
      if (cursor_y >= num_rows) return false;
      return true;


  - name: resize
    parameters:
      - name: num_columns
        type: int
        default_argument: 8
      - name: num_rows
        type: int
        default_argument: 8
    guards: [ (num_rows > 0), (num_columns > 0) ]
    body: |
      this->num_rows = num_rows;
      this->num_columns = num_columns;
      
      pieces.resize(num_columns);
      for (auto &piece : pieces) piece.resize(num_rows);

      swap_piece = Tracko::Piece();

      cursor_x = 0;
      cursor_y = 0;

      return;


  - name: fill_with_random_types
    parameters:
      - name: seed
        type: uint32_t
        default_argument: 76414 /*TRAIN*/
    body: |
      static AllegroFlare::Random random(seed);

      std::vector<Tracko::Piece::TileType> tile_types = {
         Tracko::Piece::TILE_TYPE_HORIZONTAL_BAR,
         Tracko::Piece::TILE_TYPE_VERTICAL_BAR,
         Tracko::Piece::TILE_TYPE_TOP_RIGHT_CURVE,
         Tracko::Piece::TILE_TYPE_RIGHT_BOTTOM_CURVE,
         Tracko::Piece::TILE_TYPE_BOTTOM_LEFT_CURVE,
         Tracko::Piece::TILE_TYPE_LEFT_TOP_CURVE,
      };

      // Fill the board with random pieces
      for (int x=0; x<num_columns; x++)
      {
         for (int y=0; y<num_rows; y++)
         {
            Tracko::Piece* piece = get_piece(x, y);
            piece->set_tile_type(random.get_random_element(tile_types));
         }
      }

      // Set the swap piece with a random piece
      swap_piece.set_tile_type(random.get_random_element(tile_types));

      return;
    body_dependency_symbols:
      - AllegroFlare::Random


  - name: set_random_tile_with_connection
    parameters:
      - name: x
        type: int
        default_argument: 0
      - name: y
        type: int
        default_argument: 0
      - name: connecting_position
        type: Tracko::Piece::ConnectingPosition
        default_argument: Tracko::Piece::CONNECTING_POSITION_UNDEF
      - name: seed
        type: uint32_t
        default_argument: 76414 /*TRAIN*/
    guards: [ '(connecting_position != Tracko::Piece::CONNECTING_POSITION_UNDEF)' ]
    body: |
      static AllegroFlare::Random random(seed);

      Tracko::Piece *piece = get_piece(x, y);
      std::vector<Tracko::Piece::TileType> tile_types_with_connecting_position =
         piece->get_types_with_connecting_position(connecting_position);

      Tracko::Piece::TileType selected_type_with_connection = random.get_random_element(
            tile_types_with_connecting_position
         );

      piece->set_tile_type(selected_type_with_connection);
      ////Tracko::Piece::ConnectingPosition::CONNECTING_POSITION_LEFT
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


  - name: initialize_pieces
    body: |
      // Initialize the pieces on the board
      for (int x=0; x<num_columns; x++)
      {
         for (int y=0; y<num_rows; y++)
         {
            Tracko::Piece* piece = get_piece(x, y);
            piece->initialize();
         }
      }

      // Initialize the swap piece (and reveal it)
      swap_piece.initialize();
      swap_piece.reveal();


  - name: get_piece_at_cursor
    type: Tracko::Piece*
    guards: [ cursor_is_in_valid_position() ]
    body: |
      return get_piece(cursor_x, cursor_y);


  - name: get_piece
    type: Tracko::Piece*
    parameters:
      - name: x
        type: int
        default_argument: 8
      - name: y
        type: int
        default_argument: 8
    guards: [ (x >= 0), (x < num_columns), (y >= 0), (y < num_rows) ]
    body: |
      return &pieces[x][y];


  - name: is_valid_tile_coordinate
    type: bool
    parameters:
      - name: x
        type: int
        default_argument: 8
      - name: y
        type: int
        default_argument: 8
    body: |
      return (x >= 0) && (x < num_columns) && (y >= 0) && (y < num_rows);


  - name: get_swap_piece
    type: Tracko::Piece*
    body: |
      return &swap_piece;


dependencies:


  - symbol: Tracko::Piece
    headers: [ Tracko/Piece.hpp ]
  - symbol: AllegroFlare::Random
    headers: [ AllegroFlare/Random.hpp ]
  - symbol: Tracko::Piece::ConnectingPosition
    headers: [ Tracko/Piece.hpp ]


